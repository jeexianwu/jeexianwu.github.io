---
layout: default
title: C语言入门教程
categories: [program]
comments: true
---

# C语言入门教程 #
-----------------
注意：本手册适合于 **有一定实际开发经验的程序员** ，尤其是那些已经对Java/Python等语言已经很熟悉的码农兄弟，不能作为你的第一个程序开发教程！

建议在Unix-Like操作系统上使用本手册，末选是Windows平台。

原教程来自：
[http://c.learncodethehardway.org/book](http://c.learncodethehardway.org/book)

## 目录 ##

一、基础知识

 - [1.Hello World](#1)
 - [2.Makefile](#2)
 - [3.Valgrind内存分析](#3)
 - [4.变量](#4)
 - [5.数组和字符串](#5)
 - [6.for/while循环](#6)
 - [7.if/else if/else](#7)
 - [8.指针](#8)
 - [9.结构体(struct)](#9)
 - [10.堆/栈内存分配](#10)
 - [11.指针函数/函数指针](#11)
 - [12.面向对象开发](#12)
 - [13.Debug宏](#13)
 - [14.作用域](#14)
 - [15.第一个真实应用](#15)
 - [16.灵感型编程和防御型编程](#16)

二、常用数据结构

 - [Map](#1)
 - 

<a id="1">&nbsp;</a>

## 1.Hello World ##

    #include "stdio.h"

    int main(int argc, char const *argv[])
    {
        printf("Hello World!");
        return 0;
    }

使用`make`命令编译获得可执行文件：

    $ make ex1 
    cc     ex1.c   -o ex1
    $ ./ex1
    Hello world.

给`make`命令添加`CFLAGS="-Wall"`参数：

    $ CFLAGS="-Wall" make ex1 
    cc -Wall    ex1.c   -o ex1 
    $ ./ex1
    Hello world. 
    $

<a id="2">&nbsp;</a>

## 2.Makefile ##
在ex1所在目录下创建一个`Makefile`文件：

    CFLAGS=-Wall -g
    CC=clang
    all:ex1
    clean:
        rm -rf ex1

`-g`表示显示debug信息，`CC=clang`表示使用`clang`编译器。

    $ make clean
    rm -rf ex1
    $ make
    clang -Wall -g    ex1.c   -o ex1

<a id="3">&nbsp;</a>

## 3.Valgrind ##
Valgrind是一个很有用的进行C语言内存分析的工具，大多数情况下可以快速的定位程序错误

假如我们有以下程序：

    #include <stdio.h>

    void say(char *message)
    {
      printf("%s\n", message);
    }

    int main(int argc, char const *argv[])
    {
      char *a;
      say(a);
      return 0;
    }

编译运行结果：
    
    null

安装Valgrind：

    1、安装autoconf
    2、安装automake
    3、下载Valgrind源码编译并安装

使用Valgrind检查该程序：
    
    valgrind ./tutorial

我们会看到程序输出：

    ==16611== Memcheck, a memory error detector
    ==16611== Copyright (C) 2002-2012, and GNU GPL'd, by Julian Seward et al.
    ==16611== Using Valgrind-3.9.0.SVN and LibVEX; rerun with -h for copyright info
    ==16611== Command: ./tutorial
    ==16611== 
    ==16611== WARNING: Support on MacOS 10.8 is experimental and mostly broken.
    ==16611== WARNING: Expect incorrect results, assertions and crashes.
    ==16611== WARNING: In particular, Memcheck on 32-bit programs will fail to
    ==16611== WARNING: detect any errors associated with heap-allocated data.
    ==16611== 
    ==16611== Conditional jump or move depends on uninitialised value(s)
    ==16611==    at 0x159A33: __vfprintf (in /usr/lib/system/libsystem_c.dylib)
    ==16611==    by 0x158336: vfprintf_l (in /usr/lib/system/libsystem_c.dylib)
    ==16611==    by 0x150717: printf (in /usr/lib/system/libsystem_c.dylib)
    ==16611==    by 0x100000EF0: say (tutorial.c:5)
    ==16611==    by 0x100000F1E: main (tutorial.c:11)
    ==16611== 
    (null)
    ==16611== 
    ==16611== HEAP SUMMARY:
    ==16611==     in use at exit: 62,907 bytes in 364 blocks
    ==16611==   total heap usage: 515 allocs, 151 frees, 66,773 bytes allocated
    ==16611== 
    ==16611== LEAK SUMMARY:
    ==16611==    definitely lost: 8,624 bytes in 14 blocks
    ==16611==    indirectly lost: 1,168 bytes in 5 blocks
    ==16611==      possibly lost: 4,925 bytes in 68 blocks
    ==16611==    still reachable: 48,190 bytes in 277 blocks
    ==16611==         suppressed: 0 bytes in 0 blocks
    ==16611== Rerun with --leak-check=full to see details of leaked memory
    ==16611== 
    ==16611== For counts of detected and suppressed errors, rerun with: -v
    ==16611== Use --track-origins=yes to see where uninitialised values come from
    ==16611== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)

清晰地告诉我们：

    Conditional jump or move depends on uninitialised value(s)


<a id="4">&nbsp;</a>

## 4.变量 ##

    #include <stdio.h>

    int main(int argc, char const *argv[])
    {
        int v1 = 10;
        unsigned int v11 = 10;
        float v2 = 10.0f;
        double v3 = 10.1234;

        char v4 = 'a';
        char v5[] = "Ted";

        printf("int size = %d\n", (int)sizeof(v1));
        printf("unsigned int %d\n", (int)sizeof(v11));
        printf("float size = %d\n", (int)sizeof(v2));
        printf("double size = %d\n", (int)sizeof(v3));

        printf("char size = %d\n", (int)sizeof(v4));
        printf("array size = %d\n", (int)sizeof(v5));

        return 0;
    }

输出结果：
    
    int size = 4
    unsigned int 4
    float size = 4
    double size = 8
    char size = 1
    array size = 4

需要注意的是，int类型在不同的计算机上长度可能不同，一般是32位，但不排除16位的情况。

<a id="5">&nbsp;</a>

## 5.数组和字符串 ##

    #include <stdio.h>

    int main(int argc, char const *argv[])
    {
        char name[4] = {'a'};
        int number[4] = {0};

        printf("{'a'} -> %c %c %c %c\n", name[0],name[1],name[2],name[3]);
        printf("{0} -> %d %d %d %d\n", number[0],number[1],number[2],number[3]);

        name[3] = 'd';
        number[3] = 4;
        printf("{'a'} -> %c %c %c %c\n", name[0],name[1],name[2],name[3]);
        printf("{0} -> %d %d %d %d\n", number[0],number[1],number[2],number[3]);

        char *another_name = "Zed";
        printf("{'a'} -> %c %c %c %c\n", another_name[0],another_name[1]
                ,another_name[2],another_name[3]);

    }

    输出结果：

    {'a'} -> a   
    {0} -> 0 0 0 0
    {'a'} -> a   d
    {0} -> 0 0 0 4
    {'a'} -> Z e d 

使用 `char *another_name = "Zed"`是最为常用的方法，`char name[4]`所声明的name变量不可以被再次赋值，只能作为引用。

<a id="6">&nbsp;</a>

## 6.for/while循环 ##

    #include <stdio.h>

    int main(int argc, char const *argv[])
    {
        char *names[] = {
            "Roy","Linda","Mick"
        };

        int i = 0;
        for (i = 0; i < 3; ++i)
        {
            printf("%d = %s\n", i, names[i]);
        }
        printf("\n");
        i = 0;
        while(i < 3)
        {
            printf("%d = %s\n", i, names[i]);
            i++;
        }

    }


    $./a.out
    0 = Roy
    1 = Linda
    2 = Mick

    0 = Roy
    1 = Linda
    2 = Mick

`*names[]`是一个指针数组，即`names`中的元素全是指针，`*`的优先级比`[]`低，如果需要数组指针（指向一个数组的指针），可以使用`(*names)[]`。

`*names[]`可以这么理解：1、`names[]`创建了一个数组，`*names`把这个数组的元素全变为了指针。

<a id="7">&nbsp;</a>

## 6.if/else if/else ##

    #include <stdio.h>

    int main(int argc, char const *argv[])
    {

        int i = 0;
        for (i = 0; i < 12; ++i)
        {
            if(i < 4)
            {
                printf("%s\n","AA");
            } else if(i<8) {
                printf("%s\n","BB");
            } else {
                printf("%s\n","CC");
            }
        }
    }

输出结果：

    AA
    AA
    AA
    AA
    BB
    BB
    BB
    BB
    CC
    CC
    CC
    CC

<a id="8">&nbsp;</a>

## 8.指针 ##

    #include <stdio.h>

    int main(int argc, char const *argv[])
    {
        int ages[] = {23, 43, 12, 89, 2};
        char *names[] = {
                    "Alan", "Frank",
                    "Mary", "John", "Lisa"
        };
        // 获得数组长度
        int count = sizeof(ages)/sizeof(int);
        int i;
        for (i = 0; i < count; ++i)
        {
            printf("%s 's age is %d \n",names[i],ages[i]);
        }
        printf("-----------\n");

        // 使用指针进行索引
        int *cur_age = ages;
        char **cur_name = names;
        for (i = 0; i < count; ++i)
        {
            printf("%s 's age is %d \n",*(cur_name+i),*(cur_age+i));
        }
        printf("-----------\n");

        // 指针可以作为数组直接使用
        for (i = 0; i < count; ++i)
        {
            printf("%s 's age is %d \n",cur_name[i],cur_age[i]);
        }
    }

输出结果：

    Alan 's age is 23 
    Frank 's age is 43 
    Mary 's age is 12 
    John 's age is 89 
    Lisa 's age is 2 
    -----------
    Alan 's age is 23 
    Frank 's age is 43 
    Mary 's age is 12 
    John 's age is 89 
    Lisa 's age is 2 
    -----------
    Alan 's age is 23 
    Frank 's age is 43 
    Mary 's age is 12 
    John 's age is 89 
    Lisa 's age is 2

注意，指针可以作为数组用，但指针并不等于数组。`sizeof(cur_age)`的结果是指针的大小（即总是等于sizeof(int)），`sizeof(ages)`是整个数组的大小。

<a id="9">&nbsp;</a>

## 9.结构体(struct) ##
结构体可以一定程度上实现“类”的功能，但是要注意内存的申请和释放：

    #include <stdio.h>
    #include <assert.h>
    #include <stdlib.h>
    #include <string.h> 

    struct Person
    {
        char *name;
        int age;
        int height;
        int weight;
    };

    // 这是一个指针函数，返回一个指向Person结构体的指针
    struct Person *Person_create(char *name, int age, int height, int weight)
    {
        // 使用stdlib.h下的malloc申请内存，malloc返回*void类型
        struct Person *who = malloc(sizeof(struct Person));
        // 使用strdup将name所指向的字符串复制一份，当不需要使用的时候需要手动free掉，否则会内存泄露
        who->name = strdup(name);
        who->height = height;
        who->weight = weight;
        return who;
    };

    void Person_destory(struct Person *who)
    {
        assert(who != NULL);
        free(who->name);
        free(who);
    }

    void Person_print(struct Person *who) 
    {
         printf("Name: %s\n", who->name);
         printf("\tAge: %d\n", who->age); 
         printf("\tHeight: %d\n", who->height);
         printf("\tWeight: %d\n", who->weight); 
    }

    int main(int argc, char const *argv[])
    {
        struct Person *joe = Person_create("Joe Alex",20,190,150);
        struct Person *frank = Person_create("frank Blank",23,170,200);

        // 输出他们所在的内存位置和数据
        printf("joe's memory location p = %p\n", joe);
        Person_print(joe);

        printf("frank's memory location p = %p\n", frank);
        Person_print(frank);

        Person_destory(joe);
        Person_destory(frank);
    }

输出结果：

    joe's memory location p = 0x7f9b3ac03940
    Name: Joe Alex
        Age: 0
        Height: 190
        Weight: 150
    frank's memory location p = 0x7f9b3ac03960
    Name: frank Blank
        Age: 0
        Height: 170
        Weight: 200

每次用到Person都要写`struct Person`是很麻烦的，所以可以给它一个别名：

    typedef struct
    {
        char *name;
        int age;
        int height;
        int weight;
    } Person;    

这样使用的时候可以直接用`Person`:
    
    Person *who = malloc(sizeof(Person));

<a id="10">&nbsp;</a>

## 10.堆/栈内存分配 ##
这一节我们使用一些IO操作来模拟一个微型数据库，从而对堆和栈上的内存分配进行一个简单的认识。

作为一个数据库，我们提供几个必须的“类型”：`Connection`表示一个数据库链接，`Database`表示数据库（这里使用文件），`Adresss`表示一条数据库记录。

    #include <errno.h>
    #include <stdio.h>
    #include <Stdlib.h>
    #include <string.h>

    #define MAX_DATA 512
    #define MAX_ROWS 100

    struct Address
    {
        int id;
        int set;
        char name[MAX_DATA];
        char email[MAX_DATA];
    };

    struct Database
    {
        struct Address rows[MAX_ROWS];
    };

    struct Connection
    {
        FILE *file;
        struct Database *db;
    };

    void die(const char *message)
    {
        if(errno) {
            perror(message);
        } else {
            printf("Error: %s\n", message);
        }
        exit(1);
    }

    void Address_print(struct Address *addr)
    {
        printf("%d %s %s\n", 
                addr->id, addr->name, addr->email);
    }

    // 把数据库文件中的内容读取到connection中的db缓存中
    void Database_load(struct Connection *conn)
    {
        int rc = fread(conn->db, sizeof(struct Database), 1, conn->file);
        if(rc!=1) die("Faild to read database");
    }

    // 创建一个数据库文件并返回数据库连接
    struct Connection *Database_open(const char *filename, char mode)
    {
        // malloc 所分配的内存都在堆上，需要手动free掉
        struct Connection *conn = malloc(sizeof(struct Connection));
        if(!conn) die("Memory Error");
        // 同样在堆上
        conn->db = malloc(sizeof(struct Database));
        if(!conn->db) die("Memory Error");

        if(mode=='c') {
            conn->file = fopen(filename,"w");
        } else {
            conn->file = fopen(filename,"r+");
            if(conn->file) {
                Database_load(conn);
            }
        }

        if(!conn->file) die("Failed to open the file");
        return conn;
    }

    // 关闭数据库，释放所有内存
    void Database_close(struct Connection *conn)
    {
        if(conn) {
            if(conn->file) fclose(conn->file);
            if(conn->db) free(conn->db);
            free(conn);
        }
    }

    // 把数据库缓存的内容写到数据库文件中
    void Database_write(struct Connection *conn)
    {
        // 把文件内的写指针定位在file的开始处
        rewind(conn->file);
        int rc = fwrite(conn->db, sizeof(struct Database), 1, conn->file);
        if(rc!=1) die("Failed to write database");

        rc = fflush(conn->file);
        if(rc == -1) die("Cannot flush database");
    }

    // 初始化数据库缓存中的记录
    void Database_create(struct Connection *conn)
    {
        for (int i = 0; i < MAX_ROWS; ++i)
        {
            // 在栈上创建一个addr，并给他赋储值
            struct Address addr = {.id = i, .set=0};
            // 把这个变量的值复制给rows[i]
            conn->db->rows[i] = addr;
        }
    }

    // 给数据库中的某一个记录赋值
    void Database_set(struct Connection *conn, int id, const char *name, const char *email)
    {
        struct Address *addr = &conn->db->rows[id];
        if(addr->set) die("Already set, delete it first");
        
        addr->set = 1;
        char *res = strncpy(addr->name, name, MAX_DATA-1);
        addr->name[MAX_DATA-1] = '\0';
        if(!res) die("Name copy failed"); 

        res = strncpy(addr->email, email, MAX_DATA);
        if(!res) die("Email copy failed"); 
    }

    // 获得数据库中的指定记录
    void Database_get(struct Connection *conn, int id)
    {
        struct Address *addr = &conn->db->rows[id];
        if(addr->set) {
            Address_print(addr);
        } else {
            die("ID is not set.");
        }
    }

    // 删除指定记录
    void Database_delete(struct Connection *conn, int id)
    {
        // 在栈上创建一个临时变量，赋初始化值
        struct Address addr = {.id = id, .set = 0};
        // 把临时变量的值复制给rows
        conn->db->rows[id] = addr;
    }

    void Database_list(struct Connection *conn)
    {
        struct Database *db = conn->db;
        for (int i = 0; i < MAX_ROWS; ++i)
        {
            struct Address *cur = &db->rows[i];
            if(cur->set) {
                Address_print(cur);
            }
        }
    }

    int main(int argc, char const *argv[])
    {
        if(argc < 3) die("USAGE: ./tutorial <dbfile> <action> [action params]");
        const char *filename = argv[1];
        char action = argv[2][0];
        struct Connection *conn = Database_open(filename,action);

        int id = 0;
        if(argc > 3) id = atoi(argv[3]);
        if(id >= MAX_ROWS) die("There's not that many records.");

        switch(action) {
            case 'c':
                Database_create(conn); 
                Database_write(conn);
                break;
            case 'g':
                if(argc != 4) die("Need an id to get");
                Database_get(conn, id);
                break;
            case 's': 
                if(argc != 6) die("Need id, name, email to set"); 
                Database_set(conn, id, argv[4], argv[5]); 
                Database_write(conn);
                break;
            case 'd':
                if(argc != 4) die("Need id to delete"); 
                Database_delete(conn, id); 
                Database_write(conn);
                break;
            case 'l': 
                Database_list(conn);
                break;
            default: 
                die("Invalid action, only: c=create, g=get, s=set, d=del, l=list"); 
            }
            Database_close(conn);
        return 0;
    }

输出结果：

    $:lcthw kuankuan$ make
    clang -Wall -g    tutorial.c   -o tutorial
    $:lcthw kuankuan$ ./tutorial
    Error: USAGE: ./tutorial <dbfile> <action> [action params]
    $:lcthw kuankuan$ ./tutorial db.dat c
    $:lcthw kuankuan$ ./tutorial db.dat s 1 zed zed@zed.com
    $:lcthw kuankuan$ ./tutorial db.dat s 2 frank frank@zedshaw.com
    $:lcthw kuankuan$ ./tutorial db.dat s 3 joe joe@zedshaw.com
    $:lcthw kuankuan$ ./tutorial db.dat l
    1 zed zed@zed.com
    2 frank frank@zedshaw.com
    3 joe joe@zedshaw.com
    $:lcthw kuankuan$ ./tutorial db.dat d 3
    $:lcthw kuankuan$ ./tutorial db.dat l
    1 zed zed@zed.com
    2 frank frank@zedshaw.com
    $:lcthw kuankuan$ ./tutorial db.dat g 2
    2 frank frank@zedshaw.com
    $:lcthw kuankuan$ ./tutorial db.dat g 1
    1 zed zed@zed.com

对于上面的程序，有以下几点需要注意：

1. 如果一段内存不是用`malloc`分配的，那么它就在栈上，反之则是在堆上。
2. 对于一个小模块，务必在开始的时候使用一个函数如`Database_open`分配所有需要的内存，结束的时候使用`Database_close`释放所有内存。

<a id="11">&nbsp;</a>

## 11.指针函数/函数指针 ##

### 指针函数(A Function That Return Pointer) ###
指针函数是指一个能够范围指针的函数，例如，以下函数返回一个指向`Connection`的指针：

    struct Connection *Database_open(const char *filename, char mode)
    {
        // TODO
    }

### 函数指针(A Pointer to Function) ###
函数指针是指一个指向函数的指针，如以下形式：

    int (*test)(int a, int b);

使用方法：

    1、test = &Function;
    2、test = Function;

下面是一个实例程序：

    #include <errno.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    void die(const char *message)
    {
        if(errno) {
            perror(message);
        } else {
            printf("%s\n", message);
        }
        exit(1);
    }

    // 比较两个数的大小，预定义的函数指针，可以在别的函数内直接使用
    typedef int (*compare_cb)(int a, int b);

    // 经典的冒泡排序
    int *bubble_sort(int *numbers, int count, compare_cb cmp)
    {
        int temp = 0;
        // 在堆上分配返回数组
        int *target = malloc(count * sizeof(int));

        if(!target) die("Memory Error");
        // 把numbers上的字节复制到target上
        memcpy(target, numbers, count * sizeof(int));

        for (int i = 0; i < count; i++)
        {
            for (int j = 0; j < count-1; j++)
            {
                if(cmp(target[j],target[j+1]) > 0) {
                    temp = target[j+1];
                    target[j+1] = target[j];
                    target[j] = temp;
                }
            }
        }
        return target;
    }

    // 参数与预定义的compare_cb参数和返回值一样
    int sorted_order(int a, int b)
    {
        return a - b;
    }

    int reverse_order(int a, int b)
    {
        return b - a;
    }

    int strange_order(int a, int b)
    {
        if(a == 0 || b == 0) {
            return 0;
        } else {
            return a % b;
        }
    }

    void test_sorting(int *numbers, int count, compare_cb cmp)
    {
        int *sorted = bubble_sort(numbers, count, cmp);
        if(!sorted) die("Failed to sort as requested.");
        for (int i = 0; i < count; ++i)
        {
            printf("%d ", sorted[i]);
        }
        printf("\n");
        free(sorted);
    }

    int main(int argc, char const *argv[])
    {
        if(argc < 2) die("USAGE ./tutorial 3 5 8 9 6 1 4");
        int count = argc - 1;

        const char **inputs = argv + 1;

        int *numbers = malloc(count * sizeof(int));
        if(!numbers) die("Memory error."); 

        for (int i = 0; i < count; ++i)
        {
            numbers[i] = atoi(inputs[i]);
        }
        printf("sorted \n");
        test_sorting(numbers, count, sorted_order);
        printf("reverse \n");
        test_sorting(numbers, count, reverse_order);
        printf("strange \n");
        test_sorting(numbers, count, strange_order);

        return 0;
    }

<a id="12">&nbsp;</a>

## 12.面向对象开发 ##
C语言也可以实现面向对象的开发，同时通过CPP(C Pre-Processor)连接多个不同的文件，C语言完全可以胜任大型软件的开发。

作为一个面向对象的程序，我们在设计之初就需要把“类”的概念单独拿出来放到一个header文件内，如下面的`object.h`：

    #ifndef _object_h
    #define _object_h

    typedef enum {
        NORTH, SOUTH, EAST, WEST
    } Direction;

    typedef struct {
        char *description;
        int (*init)(void *self);
        void (*describe)(void *self);
        void (*destroy)(void *self);
        void *(*move)(void *self, Direction direction);
        int (*attack)(void *self, int damage);
    } Object;

    int Object_init(void *self);
    void Object_destroy(void *self);
    void Object_describe(void *self);
    void *Object_move(void *self, Direction direction);
    int Object_attack(void *self, int damage);

    // 构造函数
    void *Object_new(size_t size, Object proto, char *description);

    #endif

然后通过一个同名的`object.c`文件来实现其中的函数：

    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    #include "object.h"

    void Object_destroy(void *self)
    {
        printf("object destory\n");
        Object *obj = self;
        if(obj) {
            if(obj->description) free(obj->description);
            free(obj);
        }
    }

    void Object_describe(void *self)
    {
        Object *obj = self;
        printf("%s.\n", obj->description);
    }

    int Object_init(void *self)
    {
        printf("object init\n");
        return 1;
    }

    void *Object_move(void *self, Direction direction)
    {
        printf("You can't go that direction.\n");
        return NULL;
    }

    int Object_attack(void *self, int damage)
    {
        printf("You can't attack that.\n"); 
        return 0;
    }

    void *Object_new(size_t size, Object proto, char *description)
    {
        // 为结构体中的函数指针赋值
        if(!proto.init) proto.init = Object_init;
        if(!proto.describe) proto.describe = Object_describe;
        if(!proto.destroy) proto.destroy = Object_destroy;
        if(!proto.attack) proto.attack = Object_attack;
        if(!proto.move) proto.move = Object_move;

        //分配一份大小为size的内存
        Object *el = calloc(1, size);
        *el = proto;

        el->description = strdup(description);

        // 初始化对象
        if(!el->init(el)) {
            el->destroy(el);
            return NULL;
        } else {
            return el;
        }
    }

最后，我们构造一个主函数来使用`Object`:

    #include <string.h>

    #include "object.h"

    int main(int argc, char const *argv[])
    {
      // 创建一个NPC对象，该对象可以有自定义函数覆盖父类(Object)的函数
      Object NPC = {};
      Object *obj = Object_new(sizeof(Object), NPC, "Hello Object");
      obj->destroy(obj);
      return 0;
    }

从本节的内容可以看到C掌握复杂逻辑的能力还是非常强的，并且其用法也是随着软件开发理论的发展而进步着。

<a id="13">&nbsp;</a>

## 13.Debug宏 ##
在程序的调试过程中，我们经常会需要做一些debug信息的输出，错误日志的报告等，这种时候我们可以用C语言的宏命令来实现一个简单的调试机制。

首先我们来定义一个头文件：

    #ifndef _dbg_h_
    #define _dbg_h_

    #include <stdio.h>
    #include <errno.h>
    #include <string.h>
    // 此处的含义是，如果用户在别的程序中指定NDEBUG，就不会输出任何调试信息，方便发布产品
    #ifdef NDEBUG
    #define debug(M, ...)
    #else
    /*
      ##__VA_ARGS__ 表示把所有其他参数原样替换进来
      __FILE__,__LINE__表示当前文件和当前行
    */
    #define debug(M, ...) fprintf(stderr, "DEBUG %s:%d: " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)
    #endif

    #define clean_errno() (errno == 0 ? "None" : strerror(errno))
    #define log_err(M, ...) fprintf(stderr, "[ERROR] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)
    #define log_warn(M, ...) fprintf(stderr, "[WARN] (%s:%d: errno: %s) " M "\n", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)
    #define log_info(M, ...) fprintf(stderr, "[INFO] (%s:%d) " M "\n", __FILE__, __LINE__, ##__VA_ARGS__)
    #define check(A, M, ...) if(!(A)) { log_err(M, ##__VA_ARGS__); errno=0; goto error; }
    #define sentinel(M, ...)  { log_err(M, ##__VA_ARGS__); errno=0; goto error; }
    #define check_mem(A) check((A), "Out of memory.")
    #define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__); errno=0; goto error; }
    #endif

使用`dbg.h`：

    #include <stdlib.h>
    #include <stdio.h>

    #include "dbg.h"

    void test_debug()
    {
        // 编译器会在编译时把该语句替换成宏内的语句
        debug("I have Brown Hair.");

        debug("I am %d years old.", 37);
    }

    void test_log_err()
    {
        log_err("I believe everything is broken.");
        log_err("There are %d problems in %s.", 0, "space");
    }

    void test_log_warn()
    {
        log_warn("You can safely ignore this.");
        log_warn("Maybe consider looking at: %s.", "/etc/passwd");
    }

    void test_log_info()
    {
        log_info("Well I did something mundane.");
        log_info("It happened %f times today.", 1.3f);
    }

    int test_check(char *file_name)
    {
      FILE *input = NULL;
      char *block = NULL;

      block = malloc(100);
      check_mem(block); // should work

      input = fopen(file_name,"r");
      check(input, "Failed to open %s.", file_name);

      free(block);
      fclose(input);
      return 0;
    error:
      if(block) free(block);
      if(input) fclose(input);
      return -1;
    }

    int test_sentinel(int code)
    {
      char *temp = malloc(100);
      check_mem(temp);

      switch(code) {
        case 1:
          log_info("It worked.");
          break;
        default:
          sentinel("I shouldn't run.");
      }

      free(temp);
      return 0;
    error:
      if(temp) free(temp);
      return -1;
    }

    int test_check_mem()
    {
      char *test = NULL;
      check_mem(test);

      free(test);
      return 1;
    error:
      return -1;
    }

    int test_check_debug()
    {
      int i = 0;
      check_debug(i != 0, "Oops, I was 0.");
      return 0;
    error:
      return -1;
    }

    int main(int argc, char *argv[])
    {
      check(argc == 2, "Need an argument.");

      test_debug();
      test_log_err();
      test_log_warn();
      test_log_info();

      check(test_check("ex20.c") == 0, "failed with ex20.c");
      check(test_check(argv[1]) == -1, "failed with argv");
      check(test_sentinel(1) == 0, "test_sentinel failed.");
      check(test_sentinel(100) == -1, "test_sentinel failed.");
      check(test_check_mem() == -1, "test_check_mem failed.");
      check(test_check_debug() == -1, "test_check_debug failed.");

      return 0;

    error:
      return 1;
    }

输出结果为：

    $ ./a.out abc
    DEBUG dbg.c:9: I have Brown Hair.
    DEBUG dbg.c:11: I am 37 years old.
    [ERROR] (dbg.c:16: errno: None) I believe everything is broken.
    [ERROR] (dbg.c:17: errno: None) There are 0 problems in space.
    [WARN] (dbg.c:22: errno: None) You can safely ignore this.
    [WARN] (dbg.c:23: errno: None) Maybe consider looking at: /etc/passwd.
    [INFO] (dbg.c:28) Well I did something mundane.
    [INFO] (dbg.c:29) It happened 1.300000 times today.
    [ERROR] (dbg.c:41: errno: No such file or directory) Failed to open ex20.c.
    [ERROR] (dbg.c:101: errno: None) failed with ex20.c

现在，我们在任意地方只需要引入dbg.h，就可以很方便的在程序中输出调试信息了。

<a id="14">&nbsp;</a>

## 14.作用域 ##
创建头文件`scope.h`：

    #ifndef _scope_h_
    #define _scope_h_

    // THE_SIZE声明为一个外部变量，即在当前文件意外也可以访问
    extern int THE_SIZE;

    int get_age();
    void set_age(int age);

    double update_ratio(double ratio);

    void print_size();

    #endif

为其编写具体的C源码实现其声明，`scope.c`：

    #include <stdio.h>
    #include "scope.h"
    #include "dbg.h"

    int THE_SIZE = 1000;

    static int THE_AGE = 37;

    int get_age()
    {
        return THE_AGE;
    }

    void set_age(int age)
    {
        THE_AGE = age;
    }

    double update_ratio(double new_ratio)
    {
        static double ratio = 1.0;

        double old_ratio = ratio;
        ratio = new_ratio;

        return old_ratio;
    }

    void print_size()
    {
        log_info("I think size is: %d", THE_SIZE);
    }

其中在文件级别使用`static xxx`，表示该变量仅在当前文件内有效，这与其他语言不大一样。如果在函数内使用`static`变量，表示该变量作为该函数的"状态"存在，多次访问函数使用的变量相同，在正规程序中要尽力避免这种使用，它会让多线程开发变成噩梦。

<a id="15">&nbsp;</a>

## 15.第一个真实应用 ##
本节我们要开发一个叫做`devpkg`的真实C语言应用，它的主要功能是通过命令行进行软件的安装。

### 15.1 程序目标 ###

    devpkg -S
        在当前计算机上开始安装程序.
    devpkg -I
        从某个URL安装软件包.
    devpkg -L
        列出所有已安装的软件包.
    devpkg -F
        抓取源码包用来手动安装.
    devpkg -B
        抓取源码包并进行编译安装.

### 15.2 基本设计 ###

#### 1) 调用系统命令 ####
我们要从url获取软件包的源码，可以直接调用curl、git或tar命令，这样可以缩减我们的代码量，更专注于整体逻辑。

#### 2) 使用文件作为数据库 ####
为了简单起见，我们使用`/usr/local/.devpkg/db`文件作为我们的数据存储，用以追踪哪些是已经安装过的软件包，当然你也可以做的更复杂一些。

#### 3) 设定默认安装路径 ####
大多数unix-like的操作系统都会把软件安装在`/usr/local/`目录下，我们暂时也沿用这个传统。

#### 4) configure, make, make install ####
像大多数软件一样，我们的devpkg也要从这三个命令安装，它显得我们更正式一些，不是么？

#### 5) root ####
我们假设用户可以通过`sudo`拥有root权限，这样很多软件才可以正确被安装。

### 15.3 Apache Portable Runtime ###
Apache Portable Runtime(包括apr和apr-util两个包)提供了一组跨平台的底层运行接口，这样就不必针对不同的平台编写不同的代码了，我们构建在APR之上会方便很多。当然，你也可以不适用apr自己实现我们需要的功能。

我们通过以下命令安装apr：

    # 以下代码如果出现错误，则关闭该会话
    set -e      
    cd /tmp

    # apr
    curl -L -O http://archive.apache.org/dist/apr/apr-1.4.6.tar.gz
    tar -xzvf apr-1.4.6.tar.gz
    cd apr-1.4.6

    ./configure
    make
    sudo make install

    cd /tmp
    rm -rf apr-1.4.6 apr-1.4.6.tar.gz

    # apr-util
    curl -L -O http://archive.apache.org/dist/apr/apr-util-1.4.1.tar.gz

    tar -xzvf apr-util-1.4.1.tar.gz
    cd apr-util-1.4.1

    # 配置apr-util安装在apr目录下
    ./configure --with-apr=/usr/local/apr
    # you need that extra parameter to configure because
    # apr-util can't really find it because...who knows.

    make
    sudo make install

    #cleanup
    cd /tmp
    rm -rf apr-util-1.4.1* apr-1.4.6*

### 15.4 项目结构 ###
我们首先创建一个`devpkg`作为我们的项目目录，然后在其中创建README和Makefile文件。

<a id="16">&nbsp;</a>

## 16.灵感型编程和防御型编程 ##



