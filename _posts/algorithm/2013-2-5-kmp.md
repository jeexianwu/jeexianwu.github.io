---
layout: default
title: KMP字符串匹配算法
comments: true
categories: [algorithm]
---
## KMP字符串匹配算法
2013-2-5
---
介绍一个牛人的博客：[http://www.csie.ntnu.edu.tw/~u91029/index.html](http://www.csie.ntnu.edu.tw/~u91029/index.html) 博主眼睛不太能使用电脑，但是坚持总结了很多非常有用的国内外计算机方面的资料，膜拜一下，本文是在参考了博主的文章之后总结的。

### 一、传统的字符串匹配算法
---
假如源字符串为`A = "abcdefg"`，我们要在A中查找子串`B = "def"`，传统的做法是直接遍历A如果找到一个字符与B中的第一个字符相同，那么继续往后查找B的第二个字符串与A的第二个字符串相同，不同则重新跳到A的第二个字符串迭代。时间复杂度为O(m\*n)，Java实现如下所示：

{% highlight java %}
public static boolean navieMatch(String a, String b) {
        byte[] original = a.getBytes();
        byte[] search = b.getBytes();
        for (int i = 0; i < a.length(); i++) {
            for (int j = 0; j < b.length(); j++) {
                if (original[i + j] != search[j]) {
                    break;
                }
                if (j == b.length() - 1) {
                    return true;
                }
            }
        }
        return false;
    }
{% endhighlight %}

这种做法的过程大约如下图所示：

![](/images/algorithm/2-5/12.jpg)

当子串验证失败的时候，就从源串的下一个字符开始再次验证。相当于每一个源串的字符尝试做一遍子循环。

### 二、KMP算法
---
KMP是希望跳过那些不必要重复检测的字符，比如第一次循环的时候，我们已经知道了后面几个字符是什么，如果与待搜索的串头不相同，就没必要再搜索了，直接跳过即可。

比如考虑下图的情况：

![](/images/algorithm/2-5/13.jpg)

子串检索到前两个字符的时候，发现不匹配，传统做法是从源串a的下一个字符b开始继续循环验证子串，我们这里要考虑的是如何跳过b字符，下一步直接从源串的c点开始匹配。KMP需要做的就是当在c点失配的时候，子串直接与c匹配即可，而且根据覆盖函数甚至子串也不用完全从头开始。

#### 2.1 覆盖函数（Overlap Function）
---
KMP算法的核心就是这玩意儿，所以在使用KMP之前我们要先搞明白这是个什么。简单地说覆盖函数的作用就是标示头尾相同字符串的索引位置(从0开始)，如下所示：

    overlap(a)          = -1  #没有对称字符
    overlap(ab)         = -1
    overlap(aba)        = 0
    overlap(abaa)       = 0
    overlap(abaab)      = 1   #ab首尾相同
    overlap(abaabcaba)  = 2   #aba首尾相同

那么这个覆盖函数如何写呢？我们可以用[动态规划](/algorithm/2012/12/19/dynamic-programming-1.html)的思想来考虑：

![](/images/algorithm/2-5/14.png)

Java代码如下：

{% highlight java %}
public static int overlay(int j, byte[] pattern) {
        if (j <= 1) {
            return -1;
        }
        if (cache.get(j) != null) {
            return cache.get(j);
        }
        int last = overlay(j - 1, pattern);
        if (last > -1 && pattern[last + 1] == pattern[j]) {
            cache.put(j, last + 1);
        } else {
            if (pattern[0] == pattern[j]) {
                cache.put(j, 0);
            } else {
                cache.put(j, -1);
            }
        }
        return cache.get(j);
    }
{% endhighlight %}

#### 2.2 KMP（Knuth-Morris-Pratt Algorithm）
---
假设源字符串A的索引为targetIndex，要在A里查找字符串B，索引标记为patternIndex。根据覆盖函数，当在patternIndex初失配的时候，targetIndex不再从上一次开始点后移一位，而是保持不变。只需要把patternIndex往前移，移到该位置之前字符串的覆盖处，重新开始匹配：

{% highlight java %}
public static int kmpMatch(byte[] target, byte[] pattern) {
        int targetIndex = 0, patternIndex = 0;

        while (targetIndex < target.length && patternIndex < pattern.length) {
            if (target[targetIndex] == pattern[patternIndex]) {
                targetIndex++;
                patternIndex++;
            } else if (patternIndex == 0) {
                targetIndex++;
            } else {
                // 核心在于，当在patternIndex点发生失配的时候，只需要调整pattern的Index即可。
                patternIndex = overlay(patternIndex - 1, pattern) + 1;
            }
        }
        if (patternIndex == pattern.length) {
            return targetIndex - patternIndex;
        }
        return -1;
    }
{% endhighlight %}

#### 2.3 时间复杂度
---
据说KMP的时间复杂度是O(n)，可以看看Matrix67的论证，但严谨的证明目前我还没找到。

### 三、总结
---
其实KMP应该是蛮简单的，刚开始在网上搜的时候发现一堆Next函数、Shift函数，完全不知道在说什么，看了半天没弄明白，多亏了Matrix67的博客和Wikipedia。

KMP的核心其实就是那个覆盖函数，而其背后的原理据说与DFA相似，来日在讨论吧。


### 参考文档

1. http://www.matrix67.com/blog/archives/115/ <br/>
2. http://saturnman.blog.163.com/blog/static/5576112010969957130/ <br/>
